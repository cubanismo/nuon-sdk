/* Copyright (c) 1995-1998, VM Labs, Inc., All rights reserved.
 * Confidential and Proprietary Information of VM Labs, Inc
 */
/* 
 * Demos the following Graphics Primitives in MML2d library:
 * Line, Polyline, Ellipse
 * TAJ - 11/25/98 - Created
 *     - 04/14/99 - Added clut8 mode for line & ellipse.
 *                  Since the destination's dim. should be 720*480 to cover the whole display
 *                  (when a main channel & overlay channel exist),the SDRAM space of 2 Meg constrains us
 *                  to a single buffer for the main & overlay channels which causes flickering.
 *                  Change to double buffering when more SDRAM space is available by editing the
 *                  variable "pixMap" by allowing it to change its value & creating 2 buffers for each channel via
 *                  "mmlInitDisplayPixmaps"
 * 
 */
 
#include "aux2d.h"
#include <nuon/mml2d.h>
#include <nuon/msprintf.h>
#include <nuon/joystick.h>
#include <nuon/video.h>
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

#define TRUE  1
#define FALSE 0

#define INCR	10
#define INCR_SPACE 20

#define MAX_X	719
#define MAX_Y	479

#define WHITE   0xc0808000
#define BLACK   0x10808000  
#define GRAY    0x60808000  
#define YELLOW	0xd2921100
#define DEFAULT_BORDER_COLOR BLACK

#define BASE (void*)0x40000000
#define BASE_TOP (0x40000000 + 2*1024*1024)

mmlSysResources sysRes;
mmlGC gc,gcCopy;
mmlDisplayPixmap screen[1], osd[1];
VidDisplay display;
VidChannel mainch, osdch;
mmlColor ycc[256];


int screenMode = 2;   //360x240=1 or 720x480=2. screenMode affects the size of the chars generated by DebugWSint mult;
int pixMap = 0;
char buf1[SPRINTF_MAX];

void DebugWS(long dmaflags, void *dmaaddr, int xpos, int ypos, long color, const char *str);
void DisplayMainMenu();
void DisplayLineScreen();
void DisplayPolylineScreen();
void DisplayEllipseScreen();
void DisplayCompositeScreen();

void GetMainChoice();
void GetLineChoice();
void GetPolylineChoice();
void GetEllipseChoice();
void GetCompositeChoice();

#define LINE_CHOICE	0
#define POLYLINE_CHOICE	1
#define ELLIPSE_CHOICE	2
#define COMPOSITE_CHOICE 3

int mychoice=0;	

// polyline:
int32 polyxc;
int32 polyyc;
f24Dot8 polyxscale;
f24Dot8 polyyscale;
int32 polyangle;
int32 escapecode;
int32* pfigure;
int32* pfigure_clut;

int32 figure0[] = // ESC_WIDTH
{  // VM
	0x001e0000, 0xffc4001e, 0xffc4003c, 0x003c003c,
	0x80000000, 0x0000000a,
	0x003cffc4, 0xffc4ffc4, 0xffc4ffe2, 0x001e0000,
	0x80000001 };

int32 figure1[] = // ESC_END
{  // VM
	0x001e0000, 0xffc4ffe2, 0xffc4ffc4, 0x003cffc4,
    0x003c003c, 0xffc4003c, 0xffc4001e, 0x001e0000,   
	0x80000001 };

int32 figure2[] = // ESC_BREAK
{  // VM
	0x001e0000, 0xffc4001e, 0xffc4003c, 0x003c003c,
	0x80000002,
	0x003cffc4, 0xffc4ffc4, 0xffc4ffe2, 0x001e0000,
	0x80000001 };

int32 figure30[] = // ESC_COLOR1
{  // VM
	0x001e0000, 0xffc4001e, 0xffc4003c, 0x003c003c,
	0x80000003, 0xA28E2C3F, //yellow
	0x003cffc4, 0xffc4ffc4, 0xffc4ffe2, 0x001e0000,
	0x80000001 };

/*	int32 figure30[] = {
		0xffc6ffd9,0xffd0ffe0,0xfff0ffe3,0xfff3fff0,			//a llovely llovely llama
		0xfff3002a,0xfff00030,0xfff20035,0xfff70037,
		0xfff50034,0xfff30030,0xfff6002a,0x0035002a,
		0x00350020,0x00300026,0x00130025,0x000e0018,
		0x0010fff9,0x0014fff0,0x0035fff0,0x0035ffe4,
		0x0030ffe9,0x80000003,0xA28E2C3F, 0x0010ffe8,0x000affe0,0x0000ffd9,
		0xffdcffd7,0xffd9ffce,0xffd4ffce,0xffd0ffdb,
		0xffc6ffd9,0x80000001};*/

int32 figure31[] = // ESC_COLOR1 - eLine3clut & eLine7clut
{  // VM
	0x001e0000, 0xffc4001e, 0xffc4003c, 0x003c003c,
	0x80000003, 0x3100, //yellow
	0x003cffc4, 0xffc4ffc4, 0xffc4ffe2, 0x001e0000,
	0x80000001 };

int32 figure40[] = // ESC_COLOR21
{  // VM
	0x001e0000, 0xffc4001e, 0xffc4003c, 0x003c003c,
	0x80000004, 0x703A4800 /*green*/, 0xA28E2C3F /*yellow*/,
	0x003cffc4, 0xffc4ffc4, 0xffc4ffe2, 0x001e0000,
	0x80000001 };

int32 figure41[] = // ESC_COLOR21 - eLine3clut & eLine7clut
{  // VM
	0x001e0000, 0xffc4001e, 0xffc4003c, 0x003c003c,
	0x80000004, 0x6000 /*green*/, 0x3100 /*yellow*/,
	0x003cffc4, 0xffc4ffc4, 0xffc4ffe2, 0x001e0000,
	0x80000001 };

int32 figure5[] = // ESC_ALPHA
{  // VM
	0x001e0000, 0xffc4001e, 0xffc4003c, 0x003c003c,
	0x80000005, 0x00001aff,
	0x003cffc4, 0xffc4ffc4, 0xffc4ffe2, 0x001e0000,
	0x80000001 };

int32* fig_array[] = { figure0, figure1, figure2, figure30, figure40, figure5 };

	// polyline escape code:
#define ESC_BASE	0x80000000
#define ESC_MAX		0x80000005

#define ESC_WIDTH	0x80000000
#define ESC_END		0x80000001
#define ESC_BREAK	0x80000002
#define ESC_COLOR1	0x80000003
#define ESC_COLOR21	0x80000004
#define ESC_ALPHA	0x80000005

// ellipse
int32	elpXc, elpYc;
int32	elpRadius;
uint32  isClut;

// line
uint16  alpha, thick;

int main( )
{
    //  Initialize the system resources and graphics context to a default state
	mmlPowerUpGraphics( &sysRes );
	mmlInitGC( &gc, &sysRes );
    gcCopy=gc;

 /* Initialize the display configuration */
    memset(&display, 0, sizeof(display));
    display.dispwidth = -1;
    display.dispheight = -1;
    display.bordcolor = DEFAULT_BORDER_COLOR;
    display.progressive = 0;

/* Initialize a single display pixmap as a framebuffer to be used as main channel
   720 pixels wide by 480 lines tall, using 32 bit YCC-alpha pixels. */
    mmlInitDisplayPixmaps( screen, &sysRes, 720, 480, e888Alpha, 1, BASE );
//    mmlInitDisplayPixmaps( screen, &sysRes, 720, 480, e888Alpha, 2, BASE );

/* Initialize the main channel from the main display pixmap */
	mmlConfigMain( &mainch, screen, 0, 0 );

/* Initialize a single display pixmap as a CLUT framebuffer to be used as overlay channel */
   	mmlInitDisplayPixmaps( osd, &sysRes, 720, 480, eClut8, 1, (void*)(BASE_TOP - 720*480) );
//   	mmlInitDisplayPixmaps( osd, &sysRes, 720, 480, eClut8, 2, (void*)(BASE_TOP - 720*480) );

/* Create a color palette to be used in osd channel and write it to VDG */
	makePalette2( ycc );
	mmlSetClut( ycc, 0, 241 );
  	 
/* Initialize the osd channel from the osd display pixmap */
	mmlConfigOSD( &osdch, osd, 0, 0 );

/* Configure the VDG channels and activate them */
    _VidConfig(&display, &mainch, &osdch, (void *)0);


    gc.nClutAlpha = 16;    // number of gradations per color in the palette

	for(;;)
	{
		DisplayMainMenu();
		GetMainChoice();
        isClut = FALSE;
		switch(mychoice)
		{
		case LINE_CHOICE:
			gc.fixAspect = eFalse;
			gc.defaultLS.lineKind = eLine1;
			gc.defaultLS.colorBlend1 = 0x3f;
			gc.defaultLS.colorBlend2 = 0;

			gc.defaultLS.alpha	= 0x00;
			gc.defaultLS.thick	= 0x5;

			gc.defaultLS.lineRandNum[0]	= 0x2574bea7;
			gc.defaultLS.lineRandNum[1]	= 0xa3000000;
			gc.defaultLS.lineRandNum[2]	= 0x83659328;
			gc.defaultLS.lineRandNum[3]	= 0xa3000000;

			DisplayLineScreen();
			GetLineChoice();
			break;
		case POLYLINE_CHOICE:
			gc.fixAspect = eFalse;
			gc.defaultLS.lineKind = eLine5;
			gc.defaultLS.thick = 3;
			gc.defaultLS.alpha	= 0x00;
			polyxc = 360;
			polyyc = 240;
			polyxscale = 0x180;
			polyyscale = 0x180;
			polyangle = 0;
			escapecode = ESC_END;
			pfigure = figure1;

			DisplayPolylineScreen();
			GetPolylineChoice();
			break;
		case ELLIPSE_CHOICE:
			elpXc = 360;
			elpYc = 240;
			elpRadius = 100;

			gc.defaultES.width = 0xbffe;
			gc.defaultES.xScale = 0x0100;
			gc.defaultES.yScale = 0x0100;
			gc.defaultES.alpha = 0x00;
			gc.defaultES.fill = 0;
			gc.fixAspect = eFalse;
			
			DisplayEllipseScreen();
			GetEllipseChoice();
			break;
		case COMPOSITE_CHOICE:
            gc = gcCopy;
			DisplayCompositeScreen();
			GetCompositeChoice();
			break;
		}
	}
}

char* MainMenu[] = {
	"Line",
	"Polyline",
	"Ellipse",
    "Composite"
};

#define MAIN_MENU_SZ  4
#define MENU_DISPLAY_INCR 50
#define Y_START 100

void DisplayMainMenu()
{
	int i;

	// now switch to drawing on the other buffer
//	pixMap ^= 1;

	//	ClearScreens
	m2dFillColr(&gc, &screen[pixMap], NULL, GRAY);  // gray
	m2dFillColr(&gc, &osd[pixMap], NULL, 0);        // transparent

	msprintf(buf1, "2D Main Menu");    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 280, Y_START, WHITE, buf1);

	for(i=0; i<MAIN_MENU_SZ; i++)
	{
		msprintf(buf1, MainMenu[i]);    
		DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 140, Y_START+MENU_DISPLAY_INCR*(i+1),
			WHITE, buf1);
	}

	msprintf(buf1, MainMenu[mychoice]);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 140, Y_START+MENU_DISPLAY_INCR*(mychoice+1),
		YELLOW, buf1);
}


void GetMainChoice()
{
	unsigned short last_joy;
	unsigned short new_joy;

	last_joy = _Controller[1].buttons;

    for(;;)
    {
		// poll the joystick
		do
		{
		    new_joy = _Controller[1].buttons;
		} while (last_joy == new_joy);
		
		if( ButtonUp(_Controller[1]) || ButtonCUp(_Controller[1]) )
		{
			mychoice = (mychoice-1)>=0 ? mychoice-1 : MAIN_MENU_SZ-1;
			DisplayMainMenu();
		}

		else if( ButtonDown(_Controller[1]) || ButtonCDown(_Controller[1]) )
		{
			mychoice = (mychoice+1)<MAIN_MENU_SZ ? mychoice+1 : 0;
			DisplayMainMenu();
		}

		else if( ButtonStart(_Controller[1]) )
		{
			mmlReleasePixmaps( (mmlPixmap*)&screen, &sysRes, 2 );
			exit(0);
		}

		else if( ButtonA(_Controller[1]) )
		{
			return;
		}
 	
		last_joy = new_joy;
    } // for
}


void DisplayLineScreen()
{
	long color;


	// now switch to drawing on the other buffer
//	pixMap ^= 1;

	//	ClearScreens
	m2dFillColr(&gc, &screen[pixMap], NULL, GRAY);  // gray
	m2dFillColr(&gc, &osd[pixMap], NULL, 0);        // transparent

	// display line
    if(gc.defaultLS.lineKind==eLine3clut || gc.defaultLS.lineKind==eLine7clut)
    {
		gc.defaultLS.foreColor = 33;    // red
		gc.defaultLS.foreColor2	= 80;   // blue
	    m2dDraw2DLine( &gc, &osd[pixMap], 120, 320, 600, 160 );
    }
    else
    {
		gc.defaultLS.foreColor = kRed;
		gc.defaultLS.foreColor2	= kBlue;
	    m2dDraw2DLine( &gc, &screen[pixMap], 120, 320, 600, 160 );
    }


	// display parameter values
	msprintf(buf1, "Line Type:%d", gc.defaultLS.lineKind);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 30,	WHITE, buf1);
	
	if(gc.fixAspect == eFalse)
		msprintf(buf1, "Fix Aspect:no");
    else
		msprintf(buf1, "Fix Aspect:yes");
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 30, WHITE, buf1);

	msprintf(buf1, "Color1:Red");    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 70,	WHITE, buf1);




	// ***************** color check ************************
	if(gc.defaultLS.lineKind==eLine5 || gc.defaultLS.lineKind==eLine6 || gc.defaultLS.lineKind==eLine7clut)
		color = WHITE;
	else
		color = BLACK;
	msprintf(buf1, "Color2:Blue");    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 100,	color, buf1);
	// ******************************************************





	// ***************** color check ************************
	if(gc.defaultLS.lineKind==eLine6)
		color = WHITE;
	else
		color = BLACK;
	msprintf(buf1, "ColorBlend1:%02d", gc.defaultLS.colorBlend1);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 70, color, buf1);
	msprintf(buf1, "ColorBlend2:%02d", gc.defaultLS.colorBlend2);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 100, color, buf1);
	// ******************************************************





	// ***************** color check ************************
	if(gc.defaultLS.lineKind==eLine3clut || gc.defaultLS.lineKind==eLine7clut)
    {
	    msprintf(buf1, "Clut8");    
	    DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 140, WHITE, buf1);
    }
	else
    {
	    msprintf(buf1, "32 Bit");    
	    DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 140, WHITE, buf1);
    }
	// ******************************************************





	// ***************** color check ************************
	if(gc.defaultLS.lineKind==eLine3 || gc.defaultLS.lineKind==eLine5 || gc.defaultLS.lineKind==eLine6 )
		color = WHITE;
	else
		color = BLACK;
	msprintf(buf1, "Alpha:%02d", (unsigned int)gc.defaultLS.alpha);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 350, color, buf1);
	// ******************************************************





	msprintf(buf1, "             Width:%04d", (unsigned int)gc.defaultLS.thick);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 350, WHITE, buf1);





	// ***************** color check ************************
	if(gc.defaultLS.lineKind==eLine4)
		color = WHITE;
	else
		color = BLACK;
	msprintf(buf1, "Random:%08x %08x", gc.defaultLS.lineRandNum[0], gc.defaultLS.lineRandNum[1]);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 390, color, buf1);
	msprintf(buf1, "       %08x %08x", gc.defaultLS.lineRandNum[2], gc.defaultLS.lineRandNum[3]);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 420, color, buf1);
	// ******************************************************
}

void GetLineChoice()
{

	unsigned short last_joy;
	unsigned short new_joy;
	int i;

	last_joy = _Controller[1].buttons;

    for(;;)
    {
		// poll the joystick
		do
		{
			new_joy = _Controller[1].buttons;
		} while (last_joy==new_joy);

		// Line Type
		if( ButtonA(_Controller[1]))
		{
			(gc.defaultLS).lineKind = ((int)((gc.defaultLS).lineKind)+1)<=(int)eLine7clut ? 
                (int)((gc.defaultLS).lineKind)+1 : eLine1;
			DisplayLineScreen();
		}

		// Fix Aspect
		else if( ButtonB(_Controller[1]))
		{
			gc.fixAspect = (gc.fixAspect==eFalse) ? eTrue : eFalse;
			DisplayLineScreen();
		}

		// Color Blend
		else if( ButtonCLeft(_Controller[1]))
		{
			gc.defaultLS.colorBlend1 = (gc.defaultLS.colorBlend1-INCR)>=0 ? gc.defaultLS.colorBlend1-INCR : 0x3f;
			DisplayLineScreen();
		}

		else if( ButtonCRight(_Controller[1]))
		{
			gc.defaultLS.colorBlend1 = (gc.defaultLS.colorBlend1+INCR)<=0x3f ? gc.defaultLS.colorBlend1+INCR : 0;
			DisplayLineScreen();
		}

		else if( ButtonCUp(_Controller[1]))
		{
			gc.defaultLS.colorBlend2 = (gc.defaultLS.colorBlend2+INCR)<=0x3f ? gc.defaultLS.colorBlend2+INCR : 0;
			DisplayLineScreen();
		}

		else if( ButtonCDown(_Controller[1]))
		{
			gc.defaultLS.colorBlend2 = (gc.defaultLS.colorBlend2-INCR)>=0 ? gc.defaultLS.colorBlend2-INCR : 0x3f;
			DisplayLineScreen();
		}
		
		// Alpha
		if( ButtonLeft(_Controller[1]))
		{
			alpha = gc.defaultLS.alpha;
			alpha = (alpha-0x10)>=0 ? alpha-0x10 : 0xff;
			gc.defaultLS.alpha = alpha;
			DisplayLineScreen();
		}

		else if( ButtonRight(_Controller[1]))
		{
			alpha = gc.defaultLS.alpha;
			alpha = (alpha+0x10)<=0xFF ? alpha+0x10 : 0x00;
			gc.defaultLS.alpha = alpha;
			DisplayLineScreen();
		}

		// Width
		else if( ButtonUp(_Controller[1]))
		{
			thick = gc.defaultLS.thick;
			thick = (thick+1)<=0xFFFF ? thick+1 : thick & 0x0fff;
			gc.defaultLS.thick = thick;
			DisplayLineScreen();
		}

		else if( ButtonDown(_Controller[1]))
		{
			thick = gc.defaultLS.thick;
			thick = (thick-1)>=0 ? thick-1 : thick | 0xf000;
			gc.defaultLS.thick = thick;
			DisplayLineScreen();
		}

		// Random Array
		else if( ButtonR(_Controller[1]))
		{
			for(i=0;i<4;i++)
				gc.defaultLS.lineRandNum[i] += 0x10000000;
			DisplayLineScreen();
		}

		else if( ButtonL(_Controller[1]))
		{
			for(i=0;i<4;i++)
				gc.defaultLS.lineRandNum[i] -= 0x10000000;
			DisplayLineScreen();
		}

		// Exit
		else if( ButtonStart(_Controller[1]) )
		{
			return;
		}
 	
		last_joy = new_joy;
    } // for
}


void DisplayPolylineScreen()
{

	long color;

    // now switch to drawing on the other buffer
//	pixMap ^= 1;

	//	ClearScreens
	m2dFillColr(&gc, &screen[pixMap], NULL, GRAY);  // gray
	m2dFillColr(&gc, &osd[pixMap], NULL, 0);        // transparent

   if((gc.defaultLS.lineKind == eLine3clut) || (gc.defaultLS.lineKind == eLine7clut))
    {
        // set colors
		gc.defaultLS.foreColor = 33;    // red
		gc.defaultLS.foreColor2	= 80;   // blue

        // set figure
        if(escapecode == ESC_COLOR1)
            pfigure_clut=figure31;
        else if(escapecode == ESC_COLOR21)
            pfigure_clut=figure41;
        else
			pfigure_clut = fig_array[escapecode-ESC_BASE];
    }
    else
    {
        // set colors
		gc.defaultLS.foreColor = kRed;
		gc.defaultLS.foreColor2	= kBlue;

        // set figure
		pfigure = fig_array[escapecode-ESC_BASE];
    }

	// display pfigure
    if(gc.defaultLS.lineKind==eLine3clut || gc.defaultLS.lineKind==eLine7clut)
    {
	    m2dDrawPolyLine( &gc, &osd[pixMap], polyxc, polyyc, polyxscale, polyyscale, polyangle, pfigure_clut);
    }
    else
    {
	    m2dDrawPolyLine( &gc, &screen[pixMap], polyxc, polyyc, polyxscale, polyyscale, polyangle, pfigure);
    }


	// display parameter values
	msprintf(buf1, "Line Type:%d", (gc.defaultLS).lineKind);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 30, WHITE, buf1);
	
	if(gc.fixAspect == eFalse)
		msprintf(buf1, "Fix Aspect:no");
    else
		msprintf(buf1, "Fix Aspect:yes");
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 30, WHITE, buf1);

	msprintf(buf1, "xCenter:  %d", polyxc);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 60,	WHITE, buf1);
	msprintf(buf1, "yCenter:  %d", polyyc);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 90,	WHITE, buf1);

	msprintf(buf1, "xScale:   %03d", polyxscale);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 60, WHITE, buf1);
	msprintf(buf1, "yScale:   %03d", polyyscale);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 90, WHITE, buf1);

    color = WHITE;

	switch(escapecode)
	{
	case ESC_WIDTH:
		msprintf(buf1, "EscapeCode:  Width");
		break;
	case ESC_END:
		msprintf(buf1, "EscapeCode:  End");
		break;
	case ESC_BREAK:
		msprintf(buf1, "EscapeCode:  Break");
		break;
	case ESC_COLOR1:
		msprintf(buf1, "EscapeCode:  Color1");
		break;
	case ESC_COLOR21:
		msprintf(buf1, "EscapeCode:  Color1&Color2");
		break;
	case ESC_ALPHA:
        if(gc.defaultLS.lineKind == eLine3 || gc.defaultLS.lineKind == eLine5
            || gc.defaultLS.lineKind == eLine6)
            color = WHITE;
        else
            color = BLACK;
		msprintf(buf1, "EscapeCode:  Alpha");
		break;
	}

	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 370, color, buf1);

	msprintf(buf1, "Angle:       %08d", polyangle);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 400, WHITE, buf1);
}


void GetPolylineChoice()
{
	unsigned short last_joy;
	unsigned short new_joy;
	signed char xrot, yrot, new_xrot, new_yrot;

	last_joy = _Controller[1].buttons;
	xrot = _Controller[1].d1.xAxis;
	yrot = _Controller[1].d2.yAxis;

    for(;;)
    {
		// poll the joystick
		do
		{
			new_joy = _Controller[1].buttons;
			new_xrot = _Controller[1].d1.xAxis;
			new_yrot = _Controller[1].d2.yAxis;
		} while (last_joy==new_joy && new_xrot==xrot && new_yrot==yrot);

		if(last_joy!=new_joy) // process buttons first to detect exit button
		{
            // Centering
			if( ButtonCLeft(_Controller[1]))
			{
				polyxc = (polyxc-INCR)>=0 ? polyxc-INCR : MAX_X;
				DisplayPolylineScreen();
			}

			else if( ButtonCRight(_Controller[1]))
			{
				polyxc = (polyxc+INCR)<=MAX_X ? polyxc+INCR : 0;
				DisplayPolylineScreen();
			}

			else if( ButtonCUp(_Controller[1]))
			{
				polyyc = (polyyc-INCR)>=0 ? polyyc-INCR : MAX_Y;
				DisplayPolylineScreen();
			}

			else if( ButtonCDown(_Controller[1]))
			{
				polyyc = (polyyc+INCR)<=MAX_Y ? polyyc+INCR : 0;
				DisplayPolylineScreen();
			}
			
			// Scaling
			if( ButtonLeft(_Controller[1]))
			{
				polyxscale = (polyxscale-INCR)>=0x01 ? polyxscale-INCR : 0x01;
				DisplayPolylineScreen();
			}

			else if( ButtonRight(_Controller[1]))
			{
				polyxscale = (polyxscale+INCR)<=0x400 ? polyxscale+INCR : 0x400;
				DisplayPolylineScreen();
			}

			else if( ButtonUp(_Controller[1]))
			{
				polyyscale = (polyyscale+INCR)<=0x400 ? polyyscale+INCR : 0x400;
				DisplayPolylineScreen();
			}

			else if( ButtonDown(_Controller[1]))
			{
				polyyscale = (polyyscale-INCR)>=0x01 ? polyyscale-INCR : 0x01;
				DisplayPolylineScreen();
			}

			// Line Type
			else if( ButtonA(_Controller[1]))
			{
			    (gc.defaultLS).lineKind = ((int)((gc.defaultLS).lineKind)+1)<=(int)eLine7clut ? 
                    (int)((gc.defaultLS).lineKind)+1 : eLine1;
				DisplayPolylineScreen();
			}

			// Fix Aspect
			else if( ButtonB(_Controller[1]))
			{
				gc.fixAspect = (gc.fixAspect==eFalse) ? eTrue : eFalse;
				DisplayPolylineScreen();
			}

			// Escape Code
			else if( ButtonL(_Controller[1]))
			{
				escapecode = (escapecode+1) <= ESC_MAX ? escapecode+1 : ESC_BASE;
				DisplayPolylineScreen();
			}

			// Exit
			else if( ButtonStart(_Controller[1]) )
			{
				return;
			}
		}
		else  // then process standard analog stick
		{
			// convert radians to rotations (divide by pi);
			// and then shift 15 bits to the left ( multiply by 32768 since compiler does not like the
			// << bitshift operator ). NOTE: this mimics the 16.16 format of rotations.
			polyangle = (int32)( (atan2(-new_yrot, new_xrot)/(3.14)) * 32768.0 );
			DisplayPolylineScreen();
		}
 	
		last_joy = new_joy;
		xrot = new_xrot;
		yrot = new_yrot;
    } // for
}




void DisplayEllipseScreen()
{

	// now switch to drawing on the other buffer
//	pixMap ^= 1;

	//	ClearScreens
	m2dFillColr(&gc, &screen[pixMap], NULL, GRAY);  // gray
	m2dFillColr(&gc, &osd[pixMap], NULL, 0);        // transparent

	// display ellipse
    if(isClut==FALSE)
    {
        (gc.defaultES).foreColor = kBlue;
	    m2dDrawEllipse(&gc, &screen[pixMap], elpXc, elpYc, elpRadius);
    }
    else 
    {
        (gc.defaultES).foreColor = 65;  // blue in palette
	    m2dDrawEllipse(&gc, &osd[pixMap], elpXc, elpYc, elpRadius);
    }


	// display parameter values
    if(isClut==FALSE)
    {
	    msprintf(buf1, "32 Bit");    
	    DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 120, WHITE, buf1);
    }
    else 
    {
	    msprintf(buf1, "Clut8");    
	    DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 120, WHITE, buf1);
    }

	msprintf(buf1, "Radius:   %d", elpRadius);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 30,	WHITE, buf1);
	
	if(gc.fixAspect == eFalse)
		msprintf(buf1, "Fix Aspect:no");
    else
		msprintf(buf1, "Fix Aspect:yes");
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 30, WHITE, buf1);

	msprintf(buf1, "xCenter:  %d", elpXc);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 60,	WHITE, buf1);
	msprintf(buf1, "yCenter:  %d", elpYc);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 90,	WHITE, buf1);

	msprintf(buf1, "xScale:   %03d", gc.defaultES.xScale);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 60, WHITE, buf1);
	msprintf(buf1, "yScale:   %03d", gc.defaultES.yScale);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 360, 90, WHITE, buf1);

	msprintf(buf1, "BorderWidth:%04d", (unsigned int)gc.defaultES.width);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 370, WHITE, buf1);

	msprintf(buf1, "Fill: %d", gc.defaultES.fill);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 470, 370, WHITE, buf1);

	msprintf(buf1, "Alpha:      %02d", (unsigned int)gc.defaultES.alpha);    
	DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 80, 400, WHITE, buf1);

}

void GetEllipseChoice()
{

	unsigned short last_joy;
	unsigned short new_joy;
	int32	elpLinewidth;
	f24Dot8 elpXscale, elpYscale;
	uint16 elpAlpha;

	last_joy = _Controller[1].buttons;

    for(;;)
    {
		// poll the joystick
		do
		{
			new_joy = _Controller[1].buttons;
		} while (last_joy==new_joy);

        // Clut toggle
		if( _Controller[1].buttons == (JOY_Z|JOY_A) )
		{
			isClut ^= 1;
			DisplayEllipseScreen();
		}

		// Alpha
		else if( _Controller[1].buttons == (JOY_Z|JOY_C_UP) )
		{
			elpAlpha = gc.defaultES.alpha;
			elpAlpha = (elpAlpha+0x10)<=0xff ? elpAlpha+0x10 : 0;
			gc.defaultES.alpha = elpAlpha;
			DisplayEllipseScreen();
		}

		else if( _Controller[1].buttons == (JOY_Z|JOY_C_DOWN) )
		{
			elpAlpha = gc.defaultES.alpha;
			elpAlpha = (elpAlpha-0x10)>=0 ? elpAlpha-0x10 : 0xff;
			gc.defaultES.alpha = elpAlpha;
			DisplayEllipseScreen();
		}

		// Border Width
		else if( _Controller[1].buttons == (JOY_Z|JOY_C_RIGHT) )
		{
			elpLinewidth = gc.defaultES.width;
			elpLinewidth = (elpLinewidth+0xa00)<=0xffff ? elpLinewidth+0xa00 : 0;
			gc.defaultES.width = elpLinewidth;
			DisplayEllipseScreen();
		}

		else if( _Controller[1].buttons == (JOY_Z|JOY_C_LEFT) )
		{
			elpLinewidth = gc.defaultES.width;
			elpLinewidth = (elpLinewidth-0xa00)>=0x200 ? elpLinewidth-0xa00 : 0xffff;
			gc.defaultES.width = elpLinewidth;
			DisplayEllipseScreen();
		}

		// Centering
		else if( ButtonCRight(_Controller[1]))
		{
			elpXc = (elpXc+INCR_SPACE)<=MAX_X ? elpXc+INCR_SPACE : 0;
			DisplayEllipseScreen();
		}

		else if( ButtonCLeft(_Controller[1]))
		{
			elpXc = (elpXc-INCR_SPACE)>=0 ? elpXc-INCR_SPACE : MAX_X;
			DisplayEllipseScreen();
		}

		else if( ButtonCUp(_Controller[1]))
		{
			elpYc = (elpYc-INCR_SPACE)>=0 ? elpYc-INCR_SPACE : MAX_Y;
			DisplayEllipseScreen();
		}

		else if( ButtonCDown(_Controller[1]))
		{
			elpYc = (elpYc+INCR_SPACE)<=MAX_Y ? elpYc+INCR_SPACE : 0;
			DisplayEllipseScreen();
		}
		
		// Scaling
		else if( ButtonRight(_Controller[1]))
		{
			elpXscale = gc.defaultES.xScale;
			elpXscale = (elpXscale+INCR)<=0xffff ? elpXscale+INCR : 0x01;
			gc.defaultES.xScale = elpXscale;
			DisplayEllipseScreen();
		}

		else if( ButtonLeft(_Controller[1]))
		{
			elpXscale = gc.defaultES.xScale;
			elpXscale = (elpXscale-INCR)>=0x01 ? elpXscale-INCR : 0xffff;
			gc.defaultES.xScale = elpXscale;
			DisplayEllipseScreen();
		}

		else if( ButtonDown(_Controller[1]))
		{
			elpYscale = gc.defaultES.yScale;
			elpYscale = (elpYscale-INCR)>=0x01 ? elpYscale-INCR : 0xffff;
			gc.defaultES.yScale = elpYscale;
			DisplayEllipseScreen();
		}

		else if( ButtonUp(_Controller[1]))
		{
			elpYscale = gc.defaultES.yScale;
			elpYscale = (elpYscale+INCR)<=0xffff ? elpYscale+INCR : 0x01;
			gc.defaultES.yScale = elpYscale;
			DisplayEllipseScreen();
		}

		// Radius
		else if( ButtonR(_Controller[1]))
		{
			elpRadius = (elpRadius+INCR_SPACE)<=400 ? elpRadius+INCR_SPACE : 0x02;
			DisplayEllipseScreen();
		}

		else if( ButtonL(_Controller[1]))
		{
			elpRadius = (elpRadius-INCR_SPACE)>=0x02 ? elpRadius-INCR_SPACE : 400;
			DisplayEllipseScreen();
		}

		// Border Width
		else if( ButtonL(_Controller[1]) && ButtonCRight(_Controller[1]))
		{
			elpLinewidth = gc.defaultES.width;
			elpLinewidth = (elpLinewidth+INCR_SPACE)<=0xffff ? elpLinewidth+INCR_SPACE : 0x02;
			gc.defaultES.width = elpLinewidth;
			DisplayEllipseScreen();
		}

		else if( ButtonL(_Controller[1]) && ButtonCLeft(_Controller[1]))
		{
			elpLinewidth = gc.defaultES.width;
			elpLinewidth = (elpLinewidth-INCR_SPACE)>=0x02 ? elpLinewidth-INCR_SPACE : 0xffff;
			gc.defaultES.width = elpLinewidth;
			DisplayEllipseScreen();
		}

		// Fill
		else if( ButtonA(_Controller[1]))
		{
			gc.defaultES.fill = (gc.defaultES.fill==1) ? 0 : 1;
			DisplayEllipseScreen();
		}

		// Fix Aspect
		else if( ButtonB(_Controller[1]))
		{
			gc.fixAspect = (gc.fixAspect==eFalse) ? eTrue : eFalse;
			DisplayEllipseScreen();
		}

		// Exit
		else if( ButtonStart(_Controller[1]) )
		{
			return;
		}

		last_joy = new_joy;
    } // for
}


void DisplayCompositeScreen()
{
// Show palette
//	ClearScreens
/*
	m2dFillColr(&gc, &screen[pixMap], NULL, GRAY);  // gray
	m2dFillColr(&gc, &osd[pixMap], NULL, 0);        // transparent
{
	m2dRect r;
	int i,j,k=1;
	for( i=0; i<15; ++i)
	{
		for(j=0; j<16; ++j )
		{
			int col = 100+14*j;
			int row = 20*i + 50;
			int val = k<<24 | k<<16 | k<<8 |k; 
			m2dSetRect( &r, col, row, col+19, row+19 );
			m2dFillColr( &gc, &osd[pixMap], &r, val );
			k++;
		}
	}
    while(1);
}
*/

// now switch to drawing on the other buffer
//	pixMap ^= 1;

	//	ClearScreens
	m2dFillColr(&gc, &screen[pixMap], NULL, GRAY);  // gray
	m2dFillColr(&gc, &osd[pixMap], NULL, 0);        // transparent

    gc.defaultES.xScale = 0x100;
    gc.defaultES.yScale = 0x100;
    gc.defaultES.fill = 0;
    gc.defaultES.alpha = 150;

	gc.defaultLS.thick = 4;
    gc.defaultLS.alpha = 100;

    if(isClut==TRUE)
    {
	    msprintf(buf1, "Clut8");    
	    DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 300, 50, WHITE, buf1);

        gc.defaultES.width = 0xa000;
	    (gc.defaultES).foreColor = 1;
        m2dDrawQuadArc(&gc, osd, 616, 285, 17, 1);
        m2dDrawQuadArc(&gc, osd, 105, 285, 17, 2);
        m2dDrawQuadArc(&gc, osd, 105, 172, 17, 3);
        m2dDrawQuadArc(&gc, osd, 616, 172, 17, 4);

        (gc.defaultLS).lineKind = eLine3clut;
	    (gc.defaultLS).foreColor = 1;
	    m2dDraw2DLine( &gc, osd,  105, 299, 615, 299);
	    m2dDraw2DLine( &gc, osd,  630, 284, 630, 173);
	    m2dDraw2DLine( &gc, osd,  106, 157, 614, 157);
	    m2dDraw2DLine( &gc, osd,  91, 173, 91, 284);
    }
    else
    {
	    msprintf(buf1, "32 Bit");    
	    DebugWS(screen[pixMap].dmaFlags, screen[pixMap].memP, 300, 50, WHITE, buf1);

        gc.defaultES.width = 0x8000;
        gc.defaultES.foreColor = kBlack;
        m2dDrawQuadArc(&gc, screen, 616, 285, 17, 1);
        m2dDrawQuadArc(&gc, screen, 105, 285, 17, 2);
        m2dDrawQuadArc(&gc, screen, 105, 172, 17, 3);
        m2dDrawQuadArc(&gc, screen, 616, 172, 17, 4);

	    (gc.defaultLS).lineKind = eLine3;
	    (gc.defaultLS).foreColor = kBlack;
	    m2dDraw2DLine( &gc, screen,  105, 300, 615, 300);
	    m2dDraw2DLine( &gc, screen,  630, 284, 630, 173);
	    m2dDraw2DLine( &gc, screen,  106, 157, 614, 157);
	    m2dDraw2DLine( &gc, screen,  90, 173, 90, 284);
    }
}


void GetCompositeChoice()
{
	unsigned short last_joy;
	unsigned short new_joy;

	last_joy = _Controller[1].buttons;

    for(;;)
    {
		// poll the joystick
		do
		{
			new_joy = _Controller[1].buttons;
		} while (last_joy==new_joy);

        // Clut toggle
		if( _Controller[1].buttons == (JOY_Z|JOY_A) )
		{
			isClut ^= 1;
			DisplayCompositeScreen();
		}

		// Exit
		else if( ButtonStart(_Controller[1]) )
		{
			return;
		}

		last_joy = new_joy;
    } // for
}
